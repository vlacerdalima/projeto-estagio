===============================================================================
              IMPLEMENTAÇÃO DE DRAG AND DROP - VERSÃO FINAL
===============================================================================

SOBRE A IMPLEMENTAÇÃO
---------------------
Sistema de arrastar e soltar (drag and drop) implementado para os cards de
"Vendas no ano" e "Faturamento" na página de seleção de restaurantes.

A implementação permite que o usuário clique e arraste os cards para qualquer
posição na tela, mantendo a posição final após soltar o mouse.


ARQUITETURA DO CÓDIGO
----------------------

1. ESTADOS (app/page.tsx)
   - salesPosition: Posição atual do card de vendas {x, y}
   - revenuePosition: Posição atual do card de faturamento {x, y}
   - isDragging: Identifica qual card está sendo arrastado ('sales' | 'revenue')
   - salesRef, revenueRef: Referências para os elementos DOM (não usadas atualmente)

2. PREVENÇÃO DE EXPANSÃO DA TELA (app/layout.tsx)
   - overflow-x-hidden: Previne scroll horizontal da página
   - overflow-y-hidden: Previne scroll vertical da página
   - Aplicado no elemento <html> para afetar toda a aplicação


FUNCIONAMENTO DO ARRASTE
-------------------------

FASE 1: Início do Arraste (handleMouseDown)
-------------------------------------------
1. Verifica se o botão clicado é o esquerdo (button 0)
2. Previne comportamento padrão do navegador (e.preventDefault())
3. Define o card como "em arrasto" via setIsDragging(type)

4. Calcula o OFFSET:
   - Mouse Start Position: (mouseStartX, mouseStartY)
   - Card Current Position: (currentPosition.x, currentPosition.y)
   - Offset = (mouseStart - currentPosition)
   
   Este offset é a distância entre onde o usuário clicou no card e a origem
   do card no DOM. É crucial para que o card siga o mouse corretamente.


FASE 2: Durante o Arraste (handleMouseMove)
---------------------------------------------
1. Captura posição atual do mouse: (e.clientX, e.clientY)

2. Calcula nova posição:
   - newX = mousePosition.X - offsetX
   - newY = mousePosition.Y - offsetY

3. Atualiza o estado do card sendo arrastado:
   - Se type === 'sales': setSalesPosition({ x: newX, y: newY })
   - Se type === 'revenue': setRevenuePosition({ x: newX, y: newY })


FASE 3: Fim do Arraste (handleMouseUp)
----------------------------------------
1. Limpa o estado isDragging (setIsDragging(null))
2. Remove os event listeners:
   - document.removeEventListener('mousemove', handleMouseMove)
   - document.removeEventListener('mouseup', handleMouseUp)


RENDERIZAÇÃO VISUAL
--------------------

1. Transform CSS:
   style={{ transform: `translate(${position.x}px, ${position.y}px)` }}
   
   - Move o card usando CSS transform sem afetar layout
   - Preserva espaço original no fluxo do documento

2. Z-Index durante arraste:
   style={{ zIndex: isDragging === 'sales' ? 1000 : 1 }}
   
   - Card arrastado fica por cima (z-index: 1000)
   - Outros cards ficam abaixo (z-index: 1)

3. Cursor e seleção:
   - cursor-move: Cursor indica que é arrastável
   - select-none: Previne seleção de texto durante arraste


CARACTERÍSTICAS ESPECIAIS
--------------------------

✅ Prevenção de Expansão da Tela
   - overflow-x-hidden no <html> previne scroll horizontal infinito
   - overflow-y-hidden no <html> previne scroll vertical infinito
   - Tela mantém tamanho fixo baseado na viewport do usuário

✅ Reset de Posição
   - Quando o usuário seleciona um novo restaurante
   - Todas as posições voltam para { x: 0, y: 0 }
   - Cards retornam à posição original no layout

✅ Persistência de Posição
   - Posições são mantidas após soltar o mouse
   - Usuário pode reposicionar os cards livremente
   - Cada card mantém sua posição independente

✅ Event Listeners Globais
   - Ouvem eventos no document (não apenas no elemento)
   - Permitem arrastar mesmo com mouse fora do card
   - Removidos automaticamente ao finalizar arraste


DETALHES TÉCNICOS
-----------------

CALCULAÇÃO DO OFFSET:
---------------------
A chave para o arraste funcionar corretamente está no cálculo do offset:

offsetX = mouseStartX - currentPosition.x
offsetY = mouseStartY - currentPosition.y

Exemplo:
- Card está em (100, 50)
- Usuário clica em (120, 70) do card
- offset = (120-100, 70-50) = (20, 10)

Durante o movimento:
- Mouse move para (150, 100)
- Nova posição = (150-20, 100-10) = (130, 90)

Isso garante que o card mantém a mesma posição relativa ao cursor.


CSS CLASSES APLICADAS:
----------------------
- cursor-move: Muda cursor para "mão com setas" indicando arraste
- select-none: Previne seleção acidental de texto durante arraste
- transition-none: Remove animações que interfeririam no movimento
- flex-1: Cards mantêm proporção igual no layout flex


PROBLEMAS RESOLVIDOS
--------------------

1. CARD NÃO SEGUIA O MOUSE CORRETAMENTE
   ✓ Solução: Cálculo correto do offset baseado na posição atual

2. TELA EXPANDIA HORIZONTALMENTE
   ✓ Solução: overflow-x-hidden no <html>

3. TELA EXPANDIA VERTICALMENTE
   ✓ Solução: overflow-y-hidden no <html>

4. CARDS RETORNAVAM PARA POSIÇÃO ORIGINAL
   ✓ Solução: Estados de posição mantidos após mouseUp


IMPLEMENTAÇÃO ESPECÍFICA vs GENÉRICA
-------------------------------------

A implementação atual é ESPECÍFICA para os cards de sales e revenue.

Vantagens desta abordagem:
- Código direto e fácil de entender
- Sem abstrações desnecessárias
- Mais controle sobre cada card

Desvantagens:
- Se novos cards forem adicionados, código precisa ser duplicado
- Múltiplos if/else para decidir qual estado atualizar

NOTA: Para adicionar mais cards no futuro, considere refatorar para uma
implementação genérica usando hook customizado e componente reutilizável.


ADICIONAR NOVO CARD (Futuro)
-----------------------------

Para adicionar um terceiro card arrastável:

1. Adicione estado de posição:
   const [card3Position, setCard3Position] = useState<Position>({ x: 0, y: 0 });

2. Adicione estado de dragging:
   const [isDragging, setIsDragging] = useState<'sales' | 'revenue' | 'card3' | null>(null);

3. Adicione ref:
   const card3Ref = useRef<HTMLDivElement>(null);

4. Modifique handleMouseDown para incluir 'card3' no type

5. Modifique handleMouseMove para:
   if (type === 'card3') {
     setCard3Position({ x: newX, y: newY });
   }

6. Renderize o card com transform e onMouseDown


USO EM PRODUÇÃO
---------------

Este sistema foi implementado para melhorar a experiência do usuário,
permitindo que ele reorganize os cards conforme sua preferência.

Os cards são totalmente arrastáveis dentro da viewport, sem causar
expansão da página ou problemas de scroll.

O sistema é leve, performático e não adiciona dependências externas.


NOTAS DE DESENVOLVIMENTO
------------------------

Durante o desenvolvimento, foram testadas diversas abordagens:

1. Implementação específica com estados separados ✓ (ATUAL)
2. Implementação genérica com hook customizado (mais escalável)
3. Uso de bibliotecas externas como react-beautiful-dnd (evitado)

A solução atual é simples, funcional e atende perfeitamente aos requisitos
do projeto atual. Se mais cards forem necessários no futuro, a implementação
pode ser refatorada para uma solução genérica sem comprometer a funcionalidade
existente.


AUTOR
-----
Vitor Lacerda
Desenvolvido como parte do desafio técnico


===============================================================================
                        DOCUMENTAÇÃO FINAL DO DRAG AND DROP
===============================================================================

